package service

import (
	"context"
	"fmt"
	"sort"
	"sync"
	"sync/atomic"

	"capnproto.org/go/capnp/v3"
	"capnproto.org/go/capnp/v3/rpc"
	"github.com/sirupsen/logrus"

	"github.com/hiveot/hub.capnp/go/hubapi"
	"github.com/hiveot/hub/internal/caphelp"
	"github.com/hiveot/hub/pkg/resolver"
	"github.com/hiveot/hub/pkg/resolver/capserializer"
)

// ResolverService implements the IResolverService interface
type ResolverService struct {
	// the combined capabilities by providerID
	registeredCapabilities map[string][]resolver.CapabilityInfo

	// connected capability providers indexed by providerID
	connectedProviders map[string]*hubapi.CapProvider

	// mutex for updating connectedProviders and registeredCapabilities
	capsMutex sync.RWMutex

	// counter of connected clients
	connectClients atomic.Int32
}

// CapProvider provides capabilities to clients
func (svc *ResolverService) CapProvider(ctx context.Context, clientID string, clientType string) resolver.ICapProvider {
	return svc
}

// CapRegistration is used to register capabilities with the resolver
func (svc *ResolverService) CapRegistration(ctx context.Context, providerID string, clientType string) resolver.ICapRegistration {
	return svc
}

// GetCapability returns the capability with the given name, if available.
// This method will return a 'future' interface for the service providing the capability.
// This won't detect a broken connection to the provider until the capability is used.
func (svc *ResolverService) GetCapability(ctx context.Context,
	clientID, clientType, capabilityName string, args []string) (
	capability capnp.Client, err error) {

	svc.capsMutex.RLock()
	defer svc.capsMutex.RUnlock()

	// determine which service this belongs to
	var capInfo *resolver.CapabilityInfo
	var providerID string
	var provider *hubapi.CapProvider
	for id, capList := range svc.registeredCapabilities {
		for _, info := range capList {
			if info.CapabilityName == capabilityName {
				capInfo = &info
				providerID = id
				break
			}
		}
	}

	// unknown capability
	if capInfo == nil {
		err = fmt.Errorf("unknown capability '%s' requested for client '%s'", capabilityName, clientID)
		logrus.Warning(err)
		return capability, err
	}

	provider = svc.connectedProviders[providerID]
	if provider == nil || !provider.IsValid() {
		// this is no longer a valid service connection
		err = fmt.Errorf("connection to service '%s' has been lost", capInfo.ServiceID)
		logrus.Warning(err)
		// cleanup leftovers
		delete(svc.registeredCapabilities, providerID)
		delete(svc.connectedProviders, providerID)

		return capability, err
	}

	// now the provider is found, request the capability
	method, release := provider.GetCapability(ctx,
		func(params hubapi.CapProvider_getCapability_Params) error {
			err2 := params.SetCapabilityName(capabilityName)
			_ = params.SetClientID(clientID)
			_ = params.SetClientType(clientType)
			_ = params.SetArgs(caphelp.MarshalStringList(args))
			return err2
		})
	defer release()

	// return the future.
	capability = method.Capability().AddRef()

	return capability, err
}

// ListCapabilities returns list of capabilities of all connected services sorted by service and capability names
// This also verifies the connections and removes capabilities that are no longer valid.
func (svc *ResolverService) ListCapabilities(_ context.Context) ([]resolver.CapabilityInfo, error) {

	capList := make([]resolver.CapabilityInfo, 0)
	removeList := make([]string, 0)
	svc.capsMutex.RLock()
	defer svc.capsMutex.RUnlock()

	logrus.Infof("listing %d services", len(svc.registeredCapabilities))
	for providerID, serviceCaps := range svc.registeredCapabilities {
		conn := svc.connectedProviders[providerID]
		if conn == nil || !conn.IsValid() {
			removeList = append(removeList, providerID)
		} else {
			for _, capInfo := range serviceCaps {
				capList = append(capList, capInfo)
			}
		}
	}
	for _, providerID := range removeList {
		delete(svc.connectedProviders, providerID)
		delete(svc.registeredCapabilities, providerID)
	}
	sort.Slice(capList, func(i, j int) bool {
		iName := capList[i].ServiceID + capList[i].CapabilityName
		jName := capList[j].ServiceID + capList[j].CapabilityName
		return iName < jName
	})
	return capList, nil
}

// OnIncomingConnection notifies of a new incoming connection.
// If the connection is made by a service whose bootstrap client is the CapProvider
// then it will be queried for available capabilities and its connection will be kept
// for future request of its capabilities.
// If this connection closes then the capabilities will be removed by the service.
//
//	rpcConn is the incoming capnp rpcConn connection
func (svc *ResolverService) OnIncomingConnection(rpcConn *rpc.Conn) {

	//clientBoot := hubapi.CapResolver(client).AddRef()
	// test the assumption that this client supports the resolver capability
	ctx := context.Background()
	// remoteBoot is released when the connection drops
	remoteBoot := rpcConn.Bootstrap(context.Background())
	err := remoteBoot.Resolve(ctx)
	if err != nil {
		logrus.Warningf("Unable to resolve client: %s", err)
		return
	}
	// we can't tell if the remote client supports the resolver API so just make the call to find out
	capProvider := hubapi.CapProvider(remoteBoot)
	remoteBoot.State().Metadata.Put("onincomingconnection", "testing")
	connectionID := capProvider.String()
	method, release := capProvider.ListCapabilities(ctx, nil)
	defer release()
	resp, err := method.Struct()
	if err != nil {
		logrus.Infof("New connection from '%s'. This is not a provider.", connectionID)
		svc.connectClients.Add(1)
		go func() {
			<-rpcConn.Done()
			svc.connectClients.Add(-1)
			remaining := svc.connectClients.Load()
			logrus.Infof("Client connection '%s' closed. %d remaining", connectionID, remaining)
		}()
	} else {
		// liftoff, this is a client that has capabilities to offer. Store them and keep the connection.
		// add the remote client capabilities and keep track of the connection
		capInfoListCapnp, err := resp.InfoList()
		if err == nil {
			capInfoList := capserializer.UnmarshalCapabilyInfoList(capInfoListCapnp)
			// The resolver will be released on stop.
			err = svc.RegisterCapabilities(ctx, connectionID, capInfoList, capProvider)
			// cleanup
			go func() {
				<-rpcConn.Done()
				logrus.Infof("Provider connection '%s' closed. %d providers remaining",
					connectionID, len(svc.connectedProviders))
				svc.removeService(connectionID)
			}()
		}
	}
}

// Release
func (svc *ResolverService) Release() {
	// tbd
}

// RegisterCapabilities makes capabilities available to others.
// This stores the capabilities along with the provider that supports getCapability.
//
// If a registration is still active its capabilities will be updated
//
//	providerID is the unique ID of the capability provider
//	capInfo is the list with capabilities available through this provider
//	capProvider is the capnp capability provider callback interface used to obtain capabilities
func (svc *ResolverService) RegisterCapabilities(_ context.Context,
	clientID string, capInfo []resolver.CapabilityInfo, capProvider hubapi.CapProvider) error {

	svc.capsMutex.Lock()
	defer svc.capsMutex.Unlock()

	logrus.Infof("'%d' new capabilities received. Client '%s'", len(capInfo), clientID)
	metaData := capnp.Client(capProvider).State().Metadata
	logrus.Infof("metadata: %v", metaData)

	// FIXME: determine the provider's connection ID so disconnects can be detected
	//c := capnp.Client(capProvider)

	// update any existing capabilities
	providerID := capProvider.String()
	existingProvider := svc.connectedProviders[providerID]
	if existingProvider != nil && existingProvider.IsValid() {
		existingProvider.Release()
	}

	// the given provider is used beyond this call so AddRef
	newProvider := capProvider.AddRef()
	// TODO: does the ID change due to AddRef?
	providerID = newProvider.String()
	svc.connectedProviders[providerID] = &newProvider
	svc.registeredCapabilities[providerID] = capInfo
	return nil
}

// removeService after its connection closes
func (svc *ResolverService) removeService(connectionID string) {
	logrus.Infof("removing service '%s'", connectionID)
	svc.capsMutex.Lock()
	defer svc.capsMutex.Unlock()

	serviceCap := svc.connectedProviders[connectionID]
	if serviceCap != nil {
		delete(svc.connectedProviders, connectionID)
		serviceCap.Release()
	}
	serviceCapInfo := svc.registeredCapabilities[connectionID]
	if serviceCapInfo != nil {
		delete(svc.registeredCapabilities, connectionID)
	}
}

// Start currently has nothing to do as the capnpserver listens for incoming connections
func (svc *ResolverService) Start(ctx context.Context) error {
	logrus.Infof("Starting resolver service")
	return nil
}

// Stop closes all service connections (if any)
func (svc *ResolverService) Stop() (err error) {
	svc.capsMutex.Lock()
	defer svc.capsMutex.Unlock()

	remainingClients := svc.connectClients.Load()
	logrus.Infof("Stopping resolver service. %d connected providers and %d clients remaining",
		len(svc.connectedProviders), remainingClients)

	for _, serviceResolver := range svc.connectedProviders {
		serviceResolver.Release()
	}
	return err
}

// NewResolverService returns a new instance of the capability resolver
func NewResolverService() *ResolverService {
	svc := &ResolverService{
		registeredCapabilities: make(map[string][]resolver.CapabilityInfo),
		connectedProviders:     make(map[string]*hubapi.CapProvider),
		capsMutex:              sync.RWMutex{},
	}
	return svc
}
