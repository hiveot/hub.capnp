package capnpserver

import (
	"fmt"
	"net"
	"net/http"
	"time"

	"capnproto.org/go/capnp/v3"
	"capnproto.org/go/capnp/v3/rpc"
	"capnproto.org/go/capnp/v3/rpc/transport"
	"capnproto.org/go/capnp/v3/server"
	"github.com/gobwas/ws"
	"github.com/hiveot/hub.capnp/go/hubapi"
	"github.com/hiveot/hub/pkg/gateway/service"
	"github.com/sirupsen/logrus"
	websocketcapnp "zenhack.net/go/websocket-capnp"
)

// listen on http port and invoke onConnect on each new incoming websocket connection
// with the websocket based capnp transport.
// Returns error
func StartListening(lis net.Listener,
	onConnect func(conn net.Conn, capTransport transport.Transport)) error {

	http.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
		logrus.Infof("new incoming websocket connection host=%s, method=%s", req.Host, req.Method)
		up := ws.HTTPUpgrader{}

		// from: codec, err := websocketcapnp.UpgradeHTTP(up, r, w)
		conn, bufRw, _, err := up.Upgrade(req, w)
		if err != nil {
			err = fmt.Errorf("error upgrading websocket connection: %w", err)
			logrus.Error(err)
			return
		}
		if n := bufRw.Reader.Buffered(); n > 0 {
			err = fmt.Errorf("TODO: support buffered data on hijacked connection (%v bytes buffered)", n)
			logrus.Error(err)
			return
		}
		if err := bufRw.Writer.Flush(); err != nil {
			err = fmt.Errorf("Flush(): %w", err)
			logrus.Error(err)
			return
		}
		//
		codec := websocketcapnp.NewCodec(conn, true)
		capTransport := transport.New(codec)
		onConnect(conn, capTransport)
	})
	err := http.Serve(lis, nil)
	return err
}

// func wsEndpoint(w http.ResponseWriter, r *http.Request) {
// 	logrus.Infof("new incoming websocket connection host=%s, method=%s", r.Host, r.Method)
// 	up := ws.HTTPUpgrader{}
// 	codec, err := websocketcapnp.UpgradeHTTP(up, r, w)
// }

// StartGatewayWSCapnpServer starts listening for incoming capnp websocket connections.
// For each new connection new instances of the capnp server and gateway session are created.
// Each client therefore operates in its own session.
//
//	svc is the gateway service to serve
//	lis is the socket listener
//	useWS set to use a websocket transport
func StartGatewayWSCapnpServer(svc *service.GatewayService, lis net.Listener) error {
	logrus.Infof("listening on websocket address %s", lis.Addr())

	err := StartListening(lis, func(conn net.Conn, capTransport transport.Transport) {
		logrus.Infof("New connection from remote client")

		// Each incoming connection is handled in a separate session.
		session := svc.OnIncomingConnection(conn)
		if session != nil {
			capsrv := NewGatewaySessionCapnpServer(session)

			time.Sleep(time.Millisecond)
			//---
			// the bootstrap client session to pass to the remote client
			//boot := hubapi.CapGatewaySession_ServerToClient(capsrv)
			c, _ := hubapi.CapGatewaySession_Server(capsrv).(server.Shutdowner)
			methods := hubapi.CapGatewaySession_Methods(nil, capsrv)
			clientHook := server.New(methods, capsrv, c)
			clientHook.HandleUnknownMethod = capsrv.HandleUnknownMethod

			//resServer := hubapi.CapGatewaySession_NewServer(s)
			resClient := capnp.NewClient(clientHook)
			boot := hubapi.CapGatewaySession(resClient) //---

			// the RPC connection takes ownership of the bootstrap interface and will release it when the connection
			// exits. Since this is a new instance for each connection there is no need to use AddRef.
			opts := rpc.Options{
				BootstrapClient: capnp.Client(boot), //.AddRef(),
			}
			rpcConn := rpc.NewConn(capTransport, &opts)

			// The RPC connection is now established. Notify on disconnect
			go func() {
				<-rpcConn.Done()
				svc.OnConnectionClosed(conn, session)
			}()
		}
	})
	return err
}
