// Package testenv for creating mosquitto testing environment
package testenv

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/wostzone/hub/lib/client/pkg/certs"
)

// MQTT ports for test environment in the 9xxx range
const (
	MqttPortUnpw = 9883
	MqttPortCert = 9884
	MqttPortWS   = 9885
)
const (
	caCertFile     = "caCert.pem"
	caKeyFile      = "caKey.pem"
	serverCertFile = "serverCert.pem"
	serverKeyFile  = "serverKey.pem"
	pluginCertFile = "pluginCert.pem"
	pluginKeyFile  = "pluginKey.pem"
)

const mosquittoConfigFile = "mosquitto-testsetup.conf"

const mqConfigTemplate = `
# Generated by 'testenv.StartMosquitto.go'. Do not edit.

log_type error
log_type warning
log_type information
log_dest stdout
log_dest stderr
persistence false

#--- plugins and devices use certificates with MQTT
# MQTT over TLS/SSL
listener {{.mqttPortCert}}
require_certificate true
tls_version tlsv1.2
cafile {{.certFolder}}/{{.caCertFile}}
certfile {{.certFolder}}/{{.serverCertFile}}
keyfile {{.certFolder}}/{{.serverKeyFile}}

#--- consumers using username/pw with MQTT protocol over TLS/SSL
listener {{.mqttPortUnpw}}
require_certificate false
tls_version tlsv1.2
cafile {{.certFolder}}/{{.caCertFile}}
certfile {{.certFolder}}/{{.serverCertFile}}
keyfile {{.certFolder}}/{{.serverKeyFile}}
# No password needed for users while testing
allow_anonymous true

#--- consumers use username/pw with WebSockets over TLS/SSL
listener {{.mqttPortWS}}
protocol websockets
require_certificate false
tls_version tlsv1.2
cafile {{.certFolder}}/{{.caCertFile}}
certfile {{.certFolder}}/{{.serverCertFile}}
keyfile {{.certFolder}}/{{.serverKeyFile}}
# No password needed for users while testing
allow_anonymous true
`

// Createa mosquitto.conf file for testing
func CreateMosquittoConf(configFolder string, certFolder string) string {
	var output bytes.Buffer
	params := map[string]string{
		"configFolder":   configFolder,
		"certFolder":     certFolder,
		"caCertFile":     caCertFile,
		"serverCertFile": serverCertFile,
		"serverKeyFile":  serverKeyFile,
		"mqttPortCert":   fmt.Sprint(MqttPortCert),
		"mqttPortWS":     fmt.Sprint(MqttPortWS),
		"mqttPortUnpw":   fmt.Sprint(MqttPortUnpw),
	}
	confTpl, _ := template.New("").Parse(mqConfigTemplate)
	confTpl.Execute(&output, params)
	return output.String()
	// return ""
}

// SaveCerts saves the given CA and mosquitto server key and certificates as PEM files
func SaveCerts(testCerts *TestCerts, certFolder string) {
	certs.SaveX509CertToPEM(testCerts.CaCert, path.Join(certFolder, caCertFile))
	certs.SaveKeysToPEM(testCerts.CaKey, path.Join(certFolder, caKeyFile))
	certs.SaveTLSCertToPEM(testCerts.ServerCert,
		path.Join(certFolder, serverCertFile),
		path.Join(certFolder, serverKeyFile))
	certs.SaveTLSCertToPEM(testCerts.PluginCert,
		path.Join(certFolder, pluginCertFile),
		path.Join(certFolder, pluginKeyFile))
}

// StartMosquitto create a test environment with a mosquitto broker on localhost for the given home folder
// This:
//  1. Saves the CA, server and client certificates in the certFolder
//  2. Generates a mosquitto configuration in the config folder
//  3. Launches a mosquitto broker for testing.
//
// mqCmd.Process.Kill() to end the mosquitto broker
//
//  configFolder is the location to generate mosquitto configuration
//  certFolder is the location to save the certificates
//  certs are the certificates to use.
// Returns the mosquitto process
func StartMosquitto(configFolder string, certFolder string, testCerts *TestCerts) (mqCmd *exec.Cmd, err error) {

	logrus.Infof("--- Starting mosquitto broker ---")
	// mqCmd = Launch(mosqConfigPath)
	SaveCerts(testCerts, certFolder)
	// mosquitto must be in the path to execute
	mosqConf := CreateMosquittoConf(configFolder, certFolder)
	mosqConfigPath := path.Join(configFolder, mosquittoConfigFile)
	err = ioutil.WriteFile(mosqConfigPath, []byte(mosqConf), 0644)
	if err != nil {
		logrus.Fatalf("Setup: Unable to write mosquitto config file: %s", err)
	}
	mqCmd = exec.Command("mosquitto", "-c", mosqConfigPath)
	// Capture stderr in case of startup failure
	mqCmd.Stderr = os.Stderr
	mqCmd.Stdout = os.Stdout
	mqCmd.Start()
	go func() {
		mqCmd.Wait()
		logrus.Infof("--- Mosquitto has ended ---")
	}()
	// Give mosquitto some time to start
	time.Sleep(100 * time.Millisecond)

	return mqCmd, err
}

// StopMosquitto the test environment and stop the mosquitto broker
func StopMosquitto(cmd *exec.Cmd) {
	cmd.Process.Signal(os.Interrupt)
	time.Sleep(100 * time.Millisecond)
}

// // launch mosquitto with the given configuration file. This attaches stderr and stdout
// // to the current process.
// //  returns with the command or error. Use cmd.Process.Kill to terminate.
// func Launch(configFile string) (*exec.Cmd, error) {

// 	logrus.Infof("--- testenv: Starting mosquitto broker ---")

// 	// mosquitto must be in the path
// 	cmd := exec.Command("mosquitto", "-c", configFile)
// 	// Capture stderr in case of startup failure
// 	cmd.Stderr = os.Stderr
// 	cmd.Stdout = os.Stdout
// 	err := cmd.Start()
// 	if err != nil {
// 		return nil, err
// 	}
// 	go func() {
// 		cmd.Wait()
// 		logrus.Infof("--- Mosquitto has ended ---")
// 	}()
// 	// Give mosquitto some time to start
// 	time.Sleep(10 * time.Millisecond)

// 	return cmd, err
// }
