// Code generated by capnpc-go. DO NOT EDIT.

package hubapi

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	fmt "fmt"
)

// Constants defined in Resolver.capnp.
const (
	ResolverServiceName     = "resolver"
	DefaultResolverAddress  = "/tmp/hiveot-resolver.socket"
	AuthTypeUnauthenticated = "unauthenticated"
	AuthTypeAdmin           = "admin"
	AuthTypeIotDevice       = "iotdevice"
	AuthTypeUser            = "user"
	AuthTypeService         = "service"
)

type CapabilityInfo capnp.Struct

// CapabilityInfo_TypeID is the unique identifier for the type CapabilityInfo.
const CapabilityInfo_TypeID = 0xae50171d46b6aaf1

func NewCapabilityInfo(s *capnp.Segment) (CapabilityInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return CapabilityInfo(st), err
}

func NewRootCapabilityInfo(s *capnp.Segment) (CapabilityInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return CapabilityInfo(st), err
}

func ReadRootCapabilityInfo(msg *capnp.Message) (CapabilityInfo, error) {
	root, err := msg.Root()
	return CapabilityInfo(root.Struct()), err
}

func (s CapabilityInfo) String() string {
	str, _ := text.Marshal(0xae50171d46b6aaf1, capnp.Struct(s))
	return str
}

func (s CapabilityInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CapabilityInfo) DecodeFromPtr(p capnp.Ptr) CapabilityInfo {
	return CapabilityInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CapabilityInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s CapabilityInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CapabilityInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CapabilityInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s CapabilityInfo) InterfaceID() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s CapabilityInfo) SetInterfaceID(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s CapabilityInfo) MethodID() uint16 {
	return capnp.Struct(s).Uint16(8)
}

func (s CapabilityInfo) SetMethodID(v uint16) {
	capnp.Struct(s).SetUint16(8, v)
}

func (s CapabilityInfo) InterfaceName() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s CapabilityInfo) HasInterfaceName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s CapabilityInfo) InterfaceNameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s CapabilityInfo) SetInterfaceName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s CapabilityInfo) MethodName() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s CapabilityInfo) HasMethodName() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s CapabilityInfo) MethodNameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s CapabilityInfo) SetMethodName(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s CapabilityInfo) AuthTypes() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s CapabilityInfo) HasAuthTypes() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s CapabilityInfo) SetAuthTypes(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewAuthTypes sets the authTypes field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s CapabilityInfo) NewAuthTypes(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s CapabilityInfo) Protocol() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s CapabilityInfo) HasProtocol() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s CapabilityInfo) ProtocolBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s CapabilityInfo) SetProtocol(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s CapabilityInfo) ServiceID() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s CapabilityInfo) HasServiceID() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s CapabilityInfo) ServiceIDBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s CapabilityInfo) SetServiceID(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s CapabilityInfo) Network() (string, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.Text(), err
}

func (s CapabilityInfo) HasNetwork() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s CapabilityInfo) NetworkBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.TextBytes(), err
}

func (s CapabilityInfo) SetNetwork(v string) error {
	return capnp.Struct(s).SetText(5, v)
}

func (s CapabilityInfo) Address() (string, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return p.Text(), err
}

func (s CapabilityInfo) HasAddress() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s CapabilityInfo) AddressBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return p.TextBytes(), err
}

func (s CapabilityInfo) SetAddress(v string) error {
	return capnp.Struct(s).SetText(6, v)
}

// CapabilityInfo_List is a list of CapabilityInfo.
type CapabilityInfo_List = capnp.StructList[CapabilityInfo]

// NewCapabilityInfo creates a new list of CapabilityInfo.
func NewCapabilityInfo_List(s *capnp.Segment, sz int32) (CapabilityInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7}, sz)
	return capnp.StructList[CapabilityInfo](l), err
}

// CapabilityInfo_Future is a wrapper for a CapabilityInfo promised by a client call.
type CapabilityInfo_Future struct{ *capnp.Future }

func (f CapabilityInfo_Future) Struct() (CapabilityInfo, error) {
	p, err := f.Future.Ptr()
	return CapabilityInfo(p.Struct()), err
}

type CapResolverService capnp.Client

// CapResolverService_TypeID is the unique identifier for the type CapResolverService.
const CapResolverService_TypeID = 0xab76eb2c88343a05

func (c CapResolverService) ListCapabilities(ctx context.Context, params func(CapProvider_listCapabilities_Params) error) (CapProvider_listCapabilities_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xacf14758b95cf892,
			MethodID:      0,
			InterfaceName: "hubapi/Resolver.capnp:CapProvider",
			MethodName:    "listCapabilities",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(CapProvider_listCapabilities_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return CapProvider_listCapabilities_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c CapResolverService) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c CapResolverService) AddRef() CapResolverService {
	return CapResolverService(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c CapResolverService) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c CapResolverService) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c CapResolverService) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (CapResolverService) DecodeFromPtr(p capnp.Ptr) CapResolverService {
	return CapResolverService(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c CapResolverService) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c CapResolverService) IsSame(other CapResolverService) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c CapResolverService) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c CapResolverService) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A CapResolverService_Server is a CapResolverService with a local implementation.
type CapResolverService_Server interface {
	ListCapabilities(context.Context, CapProvider_listCapabilities) error
}

// CapResolverService_NewServer creates a new Server from an implementation of CapResolverService_Server.
func CapResolverService_NewServer(s CapResolverService_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(CapResolverService_Methods(nil, s), s, c)
}

// CapResolverService_ServerToClient creates a new Client from an implementation of CapResolverService_Server.
// The caller is responsible for calling Release on the returned Client.
func CapResolverService_ServerToClient(s CapResolverService_Server) CapResolverService {
	return CapResolverService(capnp.NewClient(CapResolverService_NewServer(s)))
}

// CapResolverService_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func CapResolverService_Methods(methods []server.Method, s CapResolverService_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xacf14758b95cf892,
			MethodID:      0,
			InterfaceName: "hubapi/Resolver.capnp:CapProvider",
			MethodName:    "listCapabilities",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ListCapabilities(ctx, CapProvider_listCapabilities{call})
		},
	})

	return methods
}

// CapResolverService_List is a list of CapResolverService.
type CapResolverService_List = capnp.CapList[CapResolverService]

// NewCapResolverService creates a new list of CapResolverService.
func NewCapResolverService_List(s *capnp.Segment, sz int32) (CapResolverService_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[CapResolverService](l), err
}

type CapProvider capnp.Client

// CapProvider_TypeID is the unique identifier for the type CapProvider.
const CapProvider_TypeID = 0xacf14758b95cf892

func (c CapProvider) ListCapabilities(ctx context.Context, params func(CapProvider_listCapabilities_Params) error) (CapProvider_listCapabilities_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xacf14758b95cf892,
			MethodID:      0,
			InterfaceName: "hubapi/Resolver.capnp:CapProvider",
			MethodName:    "listCapabilities",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(CapProvider_listCapabilities_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return CapProvider_listCapabilities_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c CapProvider) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c CapProvider) AddRef() CapProvider {
	return CapProvider(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c CapProvider) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c CapProvider) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c CapProvider) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (CapProvider) DecodeFromPtr(p capnp.Ptr) CapProvider {
	return CapProvider(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c CapProvider) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c CapProvider) IsSame(other CapProvider) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c CapProvider) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c CapProvider) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A CapProvider_Server is a CapProvider with a local implementation.
type CapProvider_Server interface {
	ListCapabilities(context.Context, CapProvider_listCapabilities) error
}

// CapProvider_NewServer creates a new Server from an implementation of CapProvider_Server.
func CapProvider_NewServer(s CapProvider_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(CapProvider_Methods(nil, s), s, c)
}

// CapProvider_ServerToClient creates a new Client from an implementation of CapProvider_Server.
// The caller is responsible for calling Release on the returned Client.
func CapProvider_ServerToClient(s CapProvider_Server) CapProvider {
	return CapProvider(capnp.NewClient(CapProvider_NewServer(s)))
}

// CapProvider_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func CapProvider_Methods(methods []server.Method, s CapProvider_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xacf14758b95cf892,
			MethodID:      0,
			InterfaceName: "hubapi/Resolver.capnp:CapProvider",
			MethodName:    "listCapabilities",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ListCapabilities(ctx, CapProvider_listCapabilities{call})
		},
	})

	return methods
}

// CapProvider_listCapabilities holds the state for a server call to CapProvider.listCapabilities.
// See server.Call for documentation.
type CapProvider_listCapabilities struct {
	*server.Call
}

// Args returns the call's arguments.
func (c CapProvider_listCapabilities) Args() CapProvider_listCapabilities_Params {
	return CapProvider_listCapabilities_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c CapProvider_listCapabilities) AllocResults() (CapProvider_listCapabilities_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return CapProvider_listCapabilities_Results(r), err
}

// CapProvider_List is a list of CapProvider.
type CapProvider_List = capnp.CapList[CapProvider]

// NewCapProvider creates a new list of CapProvider.
func NewCapProvider_List(s *capnp.Segment, sz int32) (CapProvider_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[CapProvider](l), err
}

type CapProvider_listCapabilities_Params capnp.Struct

// CapProvider_listCapabilities_Params_TypeID is the unique identifier for the type CapProvider_listCapabilities_Params.
const CapProvider_listCapabilities_Params_TypeID = 0xbb0d5b68acfa1d84

func NewCapProvider_listCapabilities_Params(s *capnp.Segment) (CapProvider_listCapabilities_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return CapProvider_listCapabilities_Params(st), err
}

func NewRootCapProvider_listCapabilities_Params(s *capnp.Segment) (CapProvider_listCapabilities_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return CapProvider_listCapabilities_Params(st), err
}

func ReadRootCapProvider_listCapabilities_Params(msg *capnp.Message) (CapProvider_listCapabilities_Params, error) {
	root, err := msg.Root()
	return CapProvider_listCapabilities_Params(root.Struct()), err
}

func (s CapProvider_listCapabilities_Params) String() string {
	str, _ := text.Marshal(0xbb0d5b68acfa1d84, capnp.Struct(s))
	return str
}

func (s CapProvider_listCapabilities_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CapProvider_listCapabilities_Params) DecodeFromPtr(p capnp.Ptr) CapProvider_listCapabilities_Params {
	return CapProvider_listCapabilities_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CapProvider_listCapabilities_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s CapProvider_listCapabilities_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CapProvider_listCapabilities_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CapProvider_listCapabilities_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s CapProvider_listCapabilities_Params) AuthType() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s CapProvider_listCapabilities_Params) HasAuthType() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s CapProvider_listCapabilities_Params) AuthTypeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s CapProvider_listCapabilities_Params) SetAuthType(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// CapProvider_listCapabilities_Params_List is a list of CapProvider_listCapabilities_Params.
type CapProvider_listCapabilities_Params_List = capnp.StructList[CapProvider_listCapabilities_Params]

// NewCapProvider_listCapabilities_Params creates a new list of CapProvider_listCapabilities_Params.
func NewCapProvider_listCapabilities_Params_List(s *capnp.Segment, sz int32) (CapProvider_listCapabilities_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[CapProvider_listCapabilities_Params](l), err
}

// CapProvider_listCapabilities_Params_Future is a wrapper for a CapProvider_listCapabilities_Params promised by a client call.
type CapProvider_listCapabilities_Params_Future struct{ *capnp.Future }

func (f CapProvider_listCapabilities_Params_Future) Struct() (CapProvider_listCapabilities_Params, error) {
	p, err := f.Future.Ptr()
	return CapProvider_listCapabilities_Params(p.Struct()), err
}

type CapProvider_listCapabilities_Results capnp.Struct

// CapProvider_listCapabilities_Results_TypeID is the unique identifier for the type CapProvider_listCapabilities_Results.
const CapProvider_listCapabilities_Results_TypeID = 0xf5cba8f2960769af

func NewCapProvider_listCapabilities_Results(s *capnp.Segment) (CapProvider_listCapabilities_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return CapProvider_listCapabilities_Results(st), err
}

func NewRootCapProvider_listCapabilities_Results(s *capnp.Segment) (CapProvider_listCapabilities_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return CapProvider_listCapabilities_Results(st), err
}

func ReadRootCapProvider_listCapabilities_Results(msg *capnp.Message) (CapProvider_listCapabilities_Results, error) {
	root, err := msg.Root()
	return CapProvider_listCapabilities_Results(root.Struct()), err
}

func (s CapProvider_listCapabilities_Results) String() string {
	str, _ := text.Marshal(0xf5cba8f2960769af, capnp.Struct(s))
	return str
}

func (s CapProvider_listCapabilities_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CapProvider_listCapabilities_Results) DecodeFromPtr(p capnp.Ptr) CapProvider_listCapabilities_Results {
	return CapProvider_listCapabilities_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CapProvider_listCapabilities_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s CapProvider_listCapabilities_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CapProvider_listCapabilities_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CapProvider_listCapabilities_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s CapProvider_listCapabilities_Results) InfoList() (CapabilityInfo_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return CapabilityInfo_List(p.List()), err
}

func (s CapProvider_listCapabilities_Results) HasInfoList() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s CapProvider_listCapabilities_Results) SetInfoList(v CapabilityInfo_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewInfoList sets the infoList field to a newly
// allocated CapabilityInfo_List, preferring placement in s's segment.
func (s CapProvider_listCapabilities_Results) NewInfoList(n int32) (CapabilityInfo_List, error) {
	l, err := NewCapabilityInfo_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return CapabilityInfo_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// CapProvider_listCapabilities_Results_List is a list of CapProvider_listCapabilities_Results.
type CapProvider_listCapabilities_Results_List = capnp.StructList[CapProvider_listCapabilities_Results]

// NewCapProvider_listCapabilities_Results creates a new list of CapProvider_listCapabilities_Results.
func NewCapProvider_listCapabilities_Results_List(s *capnp.Segment, sz int32) (CapProvider_listCapabilities_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[CapProvider_listCapabilities_Results](l), err
}

// CapProvider_listCapabilities_Results_Future is a wrapper for a CapProvider_listCapabilities_Results promised by a client call.
type CapProvider_listCapabilities_Results_Future struct{ *capnp.Future }

func (f CapProvider_listCapabilities_Results_Future) Struct() (CapProvider_listCapabilities_Results, error) {
	p, err := f.Future.Ptr()
	return CapProvider_listCapabilities_Results(p.Struct()), err
}

const schema_f02d0b8fc1fe2004 = "x\xda\x9c\x95]h\x1c\xd5\x1b\xc6\xdf\xe7\xcc\x9c\x9d\xf4" +
	"\xffO\x9a\x8egI[\xa1FJ\x8a\xa1\xe4\xabI\x0a" +
	"Z\x04\x9346l\x90\xb2\xb3S\xf1\x13a\xb2sB" +
	"\xa6\xd9\xddYgfcs!\x85\x12?o\x8cE\xbd" +
	"\xf2\xc2\x1b\xc1\x8f\xa0\xc5\x0bQ\xa4\x82\xd2\x1b\x91\x16\xf4" +
	"F\xf4\xce/\x104`\xa4\x85(\xa6#g6\x93\xec" +
	"\xb2\x89\x05\xef\xcey\xce\xef}\xf6\xdd\xf7}\xd8\x1d\xea" +
	"dc\xfa\xb1\x8e\xe781k\x8cg\xe2o\x8e\xd5\xfe" +
	"w\xff\xf0\xccE2\xbb\xf4X\xbf\xf3\xe6g/\xfd\xbf" +
	"\xffw\"\x8c\xbc\xcd\x0a\x10\x97\x99Ad\x7f\xc44\xd8" +
	"W\x18\x03Q\xccO\x8c>\xdf\xf7\xeb\xc2\xbbdvi" +
	"M\xfce6\x0d\xf1\x95\xe2\xc5Uf\x88\xabl?Q" +
	"|q\xfd\xf1\x8f\x1f\x9eZ[\xd9\x81\xbe\x0d\x8a#\x12" +
	"_\xb0)\xf1\xa7:\xc5k\xef|x\xea\xd0\xfe\xfc{" +
	"du\x81m\xe3\xdc0\x88F\xbegG!\xd6\x147" +
	"\xb2\xcab\x10\xe2K\x07\x0f\xfcx-g~\xd0\xd2\xfa" +
	"A~\x16\xa2\x9f\xab\xd6{\xb9\x06{\x94'\xad/\x1d" +
	"\xfake\xee\xb1\x8eO\xc8<\x0c\"\x0eeu\x9c\x7f" +
	"\x0d\x82\xc8\xf1\xfb\x08\xf1\x85sG\xca\xb2w\xeaJ\x8b" +
	"a\x99\xdf\x0e\xf1tbxN\x19.\xd5\x0d\xcf\xbcq" +
	"\xb6\xf8\xe9]\xcf\xfe\xd4\xc2/\xf2\xc3\x10/$\xfc\x92" +
	"\xe2\x97\xeb\xfc#wL--\xcf\x9f\xfa\xb9\x85\x7f\x86" +
	"\x0fC\xbc\x9a\xf0\xcb\x8a\x7f\xbd\xce\xbf\xef\x19\xaf\xfd\xf1" +
	"\xd6\x977\x1a\x1b~\x99\x7f\xa7\x1a~3i\xf8\xc9q" +
	"\xef\x89WVnn\xb4\x18~\xcb\x03\x88\xd5\xc4\xf0\x17" +
	"ex\xbdn\xf8\xf9C\xb9\x81k\x97\x06\xe3\x16~\x95" +
	"O@l$\xfc\xba\xe2\xf5\x0c\x03\xf5\xc5s\xb5\x19\xa7" +
	"\xea\x0d\x16t\x19\xfa\xa5\x05\x19\x0c\x14\x9dj\xa5z\"" +
	"\xd8\xbc\xda2X\xf0\x8a\xf2\xb4S\x86\xcc\x03h'\x86" +
	"v\"\x13\xd3q\x8a\x10\xd1n.'\x9dj\xa1\xd9\x88" +
	"(\x0f\xe45n\xe9\xc0vt\x1a\x1c\xb4\x16\x87|\xe0" +
	"/x\xaeD\x90\x07,]\xe3\x0dkF:>\xd3|" +
	"\x91\x98\xd9a\xc4%/\x8cN:U\x073^\xc9\x8b" +
	"<\x19\x12\x8d!\x0f\xfc\x8b\xbf\x93\xa0\x8b\x9d\xb9\xca\xac" +
	"\xaf>\xa2G\xd3\x89t\x10\x99\xab3D\xd6o\x1a\xac" +
	"u\x06\x13z\x16J\xbc1Md]\xd7P\x00\x03X" +
	"\x16\x8c\xc8\xdc\x08\x88\xac\xbf5\xd8m`05d\xa1" +
	"\x11\x09\x8eG\x89l\x1d\x1a\xec}J\xd7Y\x16:\x91" +
	"\xe8@\x81\xc8nWz\xaf\xd2\xb9\x96\x05'\x12G0" +
	"Md\xf7(}H\xe9\x19=\x8b\x0c\x91\xe8O\xf8>" +
	"\xa5\xdf\xadt\x83gUN\xc4qL\x10\xd9CJ\xbf" +
	"W\xe9m\x99,\xda\x88\xc4=\x89>\xaa\xf410\xc4" +
	"^%\x92\xc1\xacS$C\xe6&\xb1\x87\x18\xf6\x10\xe2" +
	"\xb2\x8c\xe6|77ID0\x88\xc1\xa0\x06\xb2[m" +
	"\\nn;eO;\xa45\x88N-\x9a;\xb3X" +
	"\x95\x84\x10{\x09y\xad\x9e\x8e\xbd\x84\xb8\x1a\xf8\x91_" +
	"\xf4K\xca;\xc5\xc3z\x00r\x84\xc9T;_\x91\xd1" +
	"S~0\xbfuw\\7\x90a\xb8U\xb3K\xac\\" +
	"9\xeb\xd4JQ\x1a\xadq\xd7\xedTeM\xf9\xfc!" +
	"\x1e\x8c\xca\xd5\xc19o\x81I?\xeaO\xc3:\x10\xfa" +
	"Ec^F[\xd6\x99\xdd\xf2\x16\x0c\xa4YJ\xa3\xd4" +
	"\x93w\x02\xa7\x8c\xd0\xd2\xb7\x12\xd2\xa1\xc2\xd0\xae\xc1:" +
	"\xc0\x1a\x06\xd2\xf0\xadw\x89]\x8a>\x18j2h\xea" +
	"\xfbhg-\x94\xc1\xad\xea\xc6]\xa3\xecU\x9a\x0a\x87" +
	"\xbb\x1d\xb7\xecUnUi\xcb\xeed\x0fM\xb5\x13\xe7" +
	"7\xb7\xf3\x9f\xc6R\x90a\xad\xa4E;\xce\xa57\xc9" +
	"\xdf\xac\xff\x80\x17Fj.\x9bA\xd9\xb7\xfdG@H" +
	"\"\xb3\xcb\xaa\xb7\x06UQ'Y\x89\xbc\xee\xa2\x13I" +
	"\xb7\xa9\xfd\x0bqm\xf39\x13y\xc93\xa5v;\xbb" +
	"\xe5\xfchR&?GM>\x85\xd8\xf3#W=\x10" +
	"\xe4?\x01\x00\x00\xff\xffk\xbf\xfc\xaf"

func init() {
	schemas.Register(schema_f02d0b8fc1fe2004,
		0x926232450a7531d7,
		0xab76eb2c88343a05,
		0xacf14758b95cf892,
		0xae50171d46b6aaf1,
		0xb21149cee31819b0,
		0xbb0d5b68acfa1d84,
		0xc44728656d257882,
		0xe48627be636aa054,
		0xe5466b9084471e59,
		0xf5cba8f2960769af,
		0xfdfeac945e694171,
		0xff2fb0ce2e4957c2)
}
